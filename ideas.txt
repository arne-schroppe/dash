
# IDEAS


## Universal Access

Universal access with / operator. E.g.
some-array/1/:birthdays//sort//match %(:person _ _ 1975)/:first
// applies a function (Maybe use another, more universal operator for that)

some-array/1
some-map/:bob/:birthday

val names = some-map/*/:name
val names = some-map/*2/:name   -- get name of first two levels
val names = some-map/**/:name   -- get name of any level

val letters = "abcdefg"/(range-inclusive 1 4) -- "bcde"
-- N.B.: there's range-exclusive and range-inclusive. range is a synonym for range-inclusive

Problem: What about private symbol methods?

-- a holds a module symbol

a/do-stuff 2 a   -- ambiguous

!a/do-stuff 2 a   -- better

We could also say, that module values are also just a special module symbol. So when we do

val mod = module val a (x) = x + 3 end

then `mod` contains a certain symbol (like :/module or something like that)

But then we would need to split module access from value acces, e.g.:

val seq = sequence//from-list [1, 2, 3]
val seq = sequence::from-list [1, 2, 3]
val seq = sequence#from-list [1, 2, 3]
val first = seq/0

But then we'd increase the number of things to keep in mind. So better:

val seq = sequence/from-list [1, 2, 3]
val first = seq/0

And for modules associated with symbols, one would do

val mod = module-of some-container
val x = mod/map (* 2) some-container

or

val x = !some-container/map (*2) some-container


## "Type class" tests

When implementing a type class (Are we going to have those?), automatically run tests against it (the minimum that the type class needs
to fulfill to behave as expected)



## data structure syntax

There are predefined macros for collection literals: map-macro and list-macro

map#[
  a -> b,
  c -> "4"
]

map-[
  a -> b,
  c -> "4"
]

val some-linked-list = add-elements list#[1, 2, 3]
val some-linked-list = add-elements list::[1, 2, 3]
val some-linked-list = add-elements list:[1, 2, 3]
val some-linked-list = add-elements list-[1, 2, 3]
val some-hash-map = add-elements map#[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map::[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map:[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map-[:one -> 1, :two -> 2, :three -> 3]

val a = list#[a, b, c, d]
val a = list:[a, b, c, d]
val a = list-[a, b, c, d]
val a = list::[a, b, c, d]
val a = list%[a, b, c, d]
val a = [a, b, c, d]

val a = ~list[a, b, c, d]
val b = ~map[a -> 1, b -> 2, c -> 3, d -> 4]
val b = @map[a -> 1, b -> 2, c -> 3, d -> 4]
val b = @map[:a -> 1, :b -> 2, :c -> 3, :d -> 4]
val b = !map[:a -> 1, :b -> 2, :c -> 3, :d -> 4]


let a = do-stuff :test # add 1 a
let a = do-stuff :test $ add 1 a
let a = do-stuff :test & add 1 a
let a = do-stuff :test, add 1 a
let a = do-stuff :test . add 1 a -- nope


### Matching ordered data structures

:list 1 (:list 2 (:list 3 :list/null)) -- module symbols can implement a null element. TODO does this even make sense?

[ 1, 2, 3 | [] ]

1 :: 2 :: 3 :: []

val new-list = [1 | old-list]
val new-list = 1 :: old-list
val new-list = :list 1 old-list


## mapping symbols

You can do this

map (:symbol _) some-list

But can you also do this?

map :symbol some-list

would it make sense to treat symbols as functions?


if they were, we could do interesting stuff like this:

foldl :numbers (range 0 4)

--> :numbers 0 1 2 3 4

well, actually it's not that interesting



## Vocabulary

:   Symbols
/   Access data inside a container (or do a division)
%   Pattern (do we need this?)
_   Missing/irrelevant value, "blank"
[]  Container
#   Like $ in Haskell (or can we find something smarter?)
@   Meta information
->  Going from one value to another (used in maps and match expressions)



## Environment

 - Infinitest
 - Modify while running (have a tool running that synchronizes to app, device)

