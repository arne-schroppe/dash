
# IDEAS



Universal access with / operator. E.g.
some-array/1/:birthdays//sort//match %(:person _ _ 1975)/:first
// applies a function (Maybe use another, more universal operator for that)o



When implementing a type class (Are we going to have those?), automatically run tests against it (the minimum that the type class needs
to fulfill to behave as expected)



## data structure syntax

There are predefined macros for collection literals: map-macro and list-macro

map#[
  a -> b,
  c -> "4"
]

map-[
  a -> b,
  c -> "4"
]

val some-linked-list = add-elements list#[1, 2, 3]
val some-linked-list = add-elements list::[1, 2, 3]
val some-linked-list = add-elements list:[1, 2, 3]
val some-linked-list = add-elements list-[1, 2, 3]
val some-hash-map = add-elements map#[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map::[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map:[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map-[:one -> 1, :two -> 2, :three -> 3]

val a = list#[a, b, c, d]
val a = list:[a, b, c, d]
val a = list-[a, b, c, d]
val a = list::[a, b, c, d]
val a = list%[a, b, c, d]
val a = [a, b, c, d]

let a = do-stuff :test # add 1 a
let a = do-stuff :test $ add 1 a
let a = do-stuff :test & add 1 a
let a = do-stuff :test, add 1 a
let a = do-stuff :test . add 1 a -- nope


### Matching ordered data structures

:list 1 (:list 2 (:list 3 :list/null)) -- module symbols can implement a null element. TODO does this even make sense?

[ 1, 2, 3 | [] ]

1 :: 2 :: 3 :: []

val new-list = [1 | old-list]
val new-list = 1 :: old-list
val new-list = :list 1 old-list


## mapping symbols

You can do this

map (:symbol _) some-list

But can you also do this?

map :symbol some-list

would it make sense to treat symbols as functions?


if they were, we could do interesting stuff like this:

foldl :numbers (range 0 4)

--> :numbers 0 1 2 3 4

well, actually it's not that interesting



