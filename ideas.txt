
# IDEAS



Universal access with / operator. E.g.
some-array/1/:birthdays//sort//match %(:person _ _ 1975)/:first
// applies a function (Maybe use another, more universal operator for that)o



When implementing a type class (Are we going to have those?), automatically run tests against it (the minimum that the type class needs
to fulfill to behave as expected)



## data structure syntax

There are predefined macros for collection literals: map-macro and list-macro

map#[
  a -> b,
  c -> "4"
]

map-[
  a -> b,
  c -> "4"
]

val some-linked-list = add-elements list#[1, 2, 3]
val some-linked-list = add-elements list::[1, 2, 3]
val some-linked-list = add-elements list:[1, 2, 3]
val some-linked-list = add-elements list-[1, 2, 3]
val some-hash-map = add-elements map#[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map::[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map:[one -> 1, :two -> 2, :three -> 3]
val some-hash-map = add-elements map-[:one -> 1, :two -> 2, :three -> 3]

val a = list#[a, b, c, d]
val a = list:[a, b, c, d]
val a = list-[a, b, c, d]
val a = list::[a, b, c, d]
val a = list%[a, b, c, d]
val a = [a, b, c, d]

let a = do-stuff :test # add 1 a
let a = do-stuff :test $ add 1 a
let a = do-stuff :test & add 1 a
let a = do-stuff :test, add 1 a
let a = do-stuff :test . add 1 a -- nope
